#动态代理

代理类并不是在程序编译的时候创建，而是在运行的过程中通过 Java 的反射机制动态的进行创建，这样的代理模式成为动态代理，对应的之前我们所说的就是静态代理了。
其实，动态代理的实现没有什么可说的，说白了都是模板代码，Java 为开发者提供了 InvocationHandler，实现该接口重写其 invoke 方法即可。

DynamicProxyHandler 内部持有的并不是一个具体的对象，而是 Object 类，而在其 invoke 方法中，又会根据具体的 Object 对象及参数调用其对应的方法。这样当我们在客户端调用时，完全是根据委托类通过 Proxy.newProxyInstance 方法动态的创建代理类。在上面的代码中，我们是通过委托类 RealSubject 动态的创建了一个代理类，通过代理类调用抽象主题中定义好的方法，实际上就会调用委托类中的具体实现。而在Java中，我们可以通过反射机制，动态的创建类及其实例，因此，我们便可以在运行时通过不同的委托类，更灵活的创建代理类，从而实现不同的功能。

实现了 InvocationHandler 接口的中介类用做“调用处理器”。当调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了具体调用的是代理类的哪个方法，args为该方法的参数。这样对代理类中的所有方法的调用都会变为对invoke的调用，可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。
